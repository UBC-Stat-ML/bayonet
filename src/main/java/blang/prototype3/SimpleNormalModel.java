package blang.prototype3;

import java.util.ArrayList;
import java.util.Collection;
import java.util.function.Supplier;

import blang.core.Model;
import blang.core.ModelComponent;


/**
 * b3 code:
 * ```
 * // optional package // if skipped, inferred from directory structure?
 * // imports
 * model { // name skipped means it is inferred from the file name
 * 
 *   // random variable declaration
 *   random Real mu
 *   random Real y
 *  
 *   laws {
 *     // bugs block (see below)
 *   }
 * }
 * ```
 */
public class SimpleNormalModel 
  implements Model 
    /* 
     * Note 1: every model { .. } generates a class implementing FactorComposite.
     * 
     * Note 2: we allow model to implement other interface(s), e.g. 'model implements XYZ',
     *         to which FactorComposite is just added if not already present.
     *         
     * Note 3: for now, let us disallow models extending other classes.
     */  
{
  
  /**
   * ```
   * random Real mu
   * ```
   */
  private final Real mu; /* Note: the actual default implementation of the 
                                  interface Real will be determined from an annotation 
                                  in the interface Real. */
                                 
  /**
   * ```
   * random Real y
   * ```
   */
  private final Real y;
  
  // TODO: we will need to figure out a clean way to automatically generate 
  //       default constructors (while still allowing adding custom constructors). 
  //       In fact, we may want to automate creation of a Factory/Builders instead?
  //       Should also think of including named arguments Normal(mean = mu, variance = .. )?
  //       However, all this can wait until this new prototype is ready.
  public SimpleNormalModel()
  {
    this.mu = new RealScalar();
    this.y = new RealScalar();
  }
  
  /**
   * ```
   * laws {
   * 
   *  // definition of mu skipped
   *  
   *  // data given mu is normal with a variance equal to the square of the mean
   *  y | Real mean = mu 
   *    ~ Normal(mean, [mean.doubleValue ** 2])
   *    
   *  // Note: the syntax "Real mean = mu" seems redundant but it is needed in some cases (e.g.
   *  //       for HMMs, where it is used to select the previous state - see MarkovChain example).
   *           
   *  // Note: to make this easier, allow for a short-hand syntax "mu" instead of "Real mu = mu". 
   *  //       This might require bounded look-ahead. Note that param's can only be accessed via 
   *  //       this second short-hand syntax.
   *  
   *  // TODO: later, it will be interesting to see if we can get rid of the ".doubleValue" (i.e. 
   *  //       some kind of deboxing, but this is not needed for this new prototype.
   *  
   *  // TODO: similarly, it might be possible to skip the lambda [..] here for deterministic 
   *  //       transforms, but again this is not needed for this new prototype.
   * }
   * ```
   */
  public Collection<? extends ModelComponent> components()
  {
    ArrayList<ModelComponent> components = new ArrayList<>();
    
    // y | Real mean = mu ~ Normal(mean, [mean.doubleValue ** 2])
    components.add(
        new Normal(y, 
            $generated_setupSubModel0Param0(mu), // One supplier for each of the two arguments (parameters) of Normal.
            $generated_setupSubModel0Param1(mu)));
    
    // mu ~ Normal(0, 1)
    components.add(
        new Normal(mu,
            $generated_setupSubModel1Param0(),
            $generated_setupSubModel1Param1()));
    
    return components;
  }

  private static /* Note: it is important that these be static,
                          this ensures that no dependency is left
                          undeclared, and avoid accidentally adding 
                          the enclosing object in the the object 
                          generated by the lambda expression below */
    Supplier<Real> $generated_setupSubModel0Param0(final Real mean)
  {
    return new Supplier<Real>() 
    {
      @Override
      public Real get()
      {
        /* This returns the Java expression translated from the Xbase expression contained in the first argument:
              y | mean ~ Normal(mean, [mean.doubleValue ** 2])
                                ^^^^
         */ 
        return mean;
      }
    };
  }
  
  private static Supplier<Real> $generated_setupSubModel0Param1(Real mean)
  {
    return new Supplier<Real>() 
    {
      @Override
      public Real get()
      {
        /* This returns the Java expression translated from the Xbase expression contained in the second argument:
              y | mean ~ Normal(mean, [mean.doubleValue ** 2])
                                      ^^^^^^^^^^^^^^^^^^^^^^^
         */ 
        return () -> Math.pow(mean.doubleValue(), 2);
      }
    };
  }
  
  private static Supplier<Real> $generated_setupSubModel1Param0()
  {
    return new Supplier<Real>() 
    {
      @Override
      public Real get()
      {
        return () -> 0.0;
      }
    };
  }
  
  private static Supplier<Real> $generated_setupSubModel1Param1()
  {
    return new Supplier<Real>() 
    {
      @Override
      public Real get()
      {
        return () -> 1.0;
      }
    };
  }
  
}
